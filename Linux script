* Getting the shell
---------------------------------------------------------------------
+ pwd // Present working directory
+ The single dot (.) // Current directory
+ The double dot (..) // Parent directory
+ A question mark (?) to present one character
+ An asterisk (*) to present any number of characters
	- ls -l my_scr?pt
	- ls -l my*
	- ls -l my_scr[ai]pt // a or i
	- ls -l f[a-i]ll // from a to i
	- ls -l f[!a]ll // not be included a
---------------------------------------------------------------------
* Handling files
---------------------------------------------------------------------
+ touch file_name // Create file
+ cp source   destination // Copy file
+ mv old_name   new_name // Rename file
+ mv file   directory // Moving file (cut paste)
+ rm -i file_name // Delete file
+ cat file_name // View file
+ more,less,tail,head file_name // View file 
---------------------------------------------------------------------
* Manage directory
---------------------------------------------------------------------
+ mkdir New_Dir // Create directory
+ rmdir New_Dir // Delete directory when empty
---------------------------------------------------------------------
* Monitoring program
---------------------------------------------------------------------
+ ps // Show processes
	- UID: The user responsible for launching the process
	- PID: The process ID of the process
	- PPID: The PID of the parent process (if a process is started by another process)
	- C: Processor utilization over the lifetime of the process
	- STIME: The system time when the process started
	- TTY: The terminal device from which the process was launched
	- TIME: The cumulative CPU time required to run the process
	- CMD: The name of the program that was started
---------------------------------------------------------------------
* Working with data files
---------------------------------------------------------------------
+ sort file // Sort
+ grep [option] pattern [file] // Search data
---------------------------------------------------------------------
* Variables
---------------------------------------------------------------------
+ Local variable
	- echo $my_variable
	  
	  my_variable=Hello
	  
	  echo $my_variable
	
	  my_variable="Hello World"

	  echo $my_variable
	
	  bash // Child bash

	  echo $my_variable // Khong hien thi gia tri bien

	  exit
+ Global variable
	- my_variable="I am Trung"
	  
	  export my_variable

	  echo $my_variable

	  bash

	  echo $my_variable

	  exit
+ Removing variable
	- echo $my_variable

	  unset my_variable
+ Variable arrays
	- mytest=(one two three four five)

	  echo ${mytest[*]}

	  echo ${mytest[2]}

---------------------------------------------------------------------
* File permission
---------------------------------------------------------------------
+ /usr/sbin/useradd -D // See the system default values used on your Linux
+ useradd -m test // Create a new user
+ userdel -r test // Remove a user
+ Permission symbols:
	-rw-rw-r--
	drwxrwxr-x
- The first field:
	- for files
	d for directories
	l for links
	c for character devices
	b for block devices
	n for network devices
- Three sets of three characters. Each set of three characters defines an access permission triplet:
	r for read permission for the object
	w for write permission for the object
	x for execute permission for the object
- The first triplet: permissions for everyone else, the second: for group members, the third: for the file owner.
+ Linux file permission codes:
Permissions 	Binary 	Octal 	Description
--- 	        000 	0 	No permissions
--x 	        001 	1 	Execute-only permission
-w- 	        010 	2 	Write-only permission
-wx 	        011 	3 	Write and execute permissions
r-- 	        100 	4 	Read-only permission
r-x 	        101 	5 	Read and execute permissions
rw- 	        110 	6 	Read and write permissions
rwx 	        111 	7 	Read, write, and execute permissions
	- default file permissions: -rw-r--r-- (644)
	- umask 0022
	- The full permission for a file is mode 666, for a directory is 777
+ Changing permissions: chmod options mode file
	- [ugoa...][[+-=][rwxXstugo...]
	u for the user
	g for the group
	o for others (everyone else)
	a for all of the above
	---------------------------
	X assigns execute permissions only if the object is a directory or if it already had execute permissions.
	s sets the UID or GID on execution.
	t saves program text.
	u sets the permissions to the owner’s permissions.
	g sets the permissions to the group’s permissions.
	o sets the permissions to the other’s permissions.
	---------------------------
	chmod o+r newfile
	chmod u+x newfile
	chmod u-x newfile
---------------------------------------------------------------------
* Script building
---------------------------------------------------------------------
+ Multiple commands: 
	date ; who
+ Displaying messages: 
	echo This is a test
	echo "This is a test to see if you're paying attention"
	echo -n "The time and date are: " // echo a text string on the same line as a command
+ User variables:
	#!/bin/bash
	# testing variables
	days=10
	guest="Katie"
	echo "$guest checked in $days days ago"
	days=5
	guest="Jessica"
	echo "$guest checked in $days days ago"
	------------------------------------
	#!/bin/bash
	# assigning a variable value to another variable

	value1=10
	value2=$value1
	echo The resulting value is $value2
+ Output redirection:
	command > outputfile
	---------------------
	date > test6
	who > test6
	---------------------
	command >> outputfile // append output from a command to an existing file
	---------------------
	date >> test6
+ Input redirection:
	command < inputfile
	---------------------
	wc < test6
		2	11	60 // output
	wc command provides a count of text in the data:
	- The number of lines in the text
	- The number of words in the text
	- The number of bytes in the text
	---------------------
	command << marker
	data
	marker
	---------------------
	wc << EOF
	> test string 1
	> test string 2
	> test string 3
	> EOF
		3	9	42 // output
+ Performing Math
	- Using brackets
	-----------------------
	var1=$[1 + 5]
	echo $var1
	
	var2=$[$var1 * 2]
	echo $var2
	-----------------------
	#!/bin/bash
	var1=100
	var2=50
	var3=45
	var4=$[$var1 * ($var2 - $var3)]
	echo The final result is $var4
	-----------------------
	- A floating-point solution:
	variable=$(echo "options; expression" | bc)
	-----------------------
	var1=$(echo "scale=4; 3.44 / 5" | bc)	
	echo The answer is $var1 // output: .6880
	-----------------------
	variable=$(bc << EOF
	options
	statements
	expressions
	EOF
	)
	-----------------------
	var1=10.46
	var2=43.67
	var3=33.2
	var4=71

	var5=$(bc << EOF
	scale = 4
	a1 = ($var1 * $var2)
	a2 = ($var3 * $var4)
	a1 + b1
	EOF
	)

	echo The final answer for this mess is $var5			
---------------------------------------------------------------------
* Structured commands
---------------------------------------------------------------------
+ if-then
	if command
	then
	    commands
	fi
	--------------------------
	#!/bin/bash
	# testing multiple commands in the then section
	# 
	testuser=trungluong
	#
	if grep $testuser /etc/passwd
	then
	   echo "This is my first command"
	   echo "This is my second command"
	   ls -a/home/$testuser/.b*
	fi
	--------------------------
	if command
	then
	   commands
	else
	   commands
	fi
	--------------------------
	testuser=NoSuchUser
	#
	if grep $testuser /etc/passwd
	then
	   echo "The bash files for user $testuser are:"
	   ls -a /home/$testuser/.b*
	   echo
	else
	   echo "The user $testuser does not exist on this system."
	   echo
	fi
	--------------------------
	if command1
	then
	   commands
	elif command2
	then
	   more commands
	fi
	--------------------------
+ Test:
	if [ condition ]
	then
	   commands
	fi
	-------------------------------------
	- Numeric:
	n1 -eq n2      Checks if n1 is equal to n2
	n1 -ge n2      Checks if n1 is greater than or equal to n2
	n1 -gt n2      Checks if n1 is greater than n2
	n1 -le n2      Checks if n1 is less than or equal to n2
	n1 -lt n2      Checks if n1 is less than n2
	n1 -ne n2      Checks if n1 is not equal to n2
	-------------------------------------
	- String:
	str1 = str2 	Checks if str1 is the same as string str2
	str1 != str2 	Checks if str1 is not the same as str2
	str1 < str2 	Checks if str1 is less than str2
	str1 > str2 	Checks if str1 is greater than str2
	-n str1 	Checks if str1 has a length greater than zero
	-z str1 	Checks if str1 has a length of zero
	-------------------------------------
	- File:
	-d file 		Checks if file exists and is a directory
	-e file 		Checks if file exists
	-f file 		Checks if file exists and is a file
	-r file 		Checks if file exists and is readable
	-s file 		Checks if file exists and is not empty
	-w file 		Checks if file exists and is writable
	-x file 		Checks if file exists and is executable
	-O file 		Checks if file exists and is owned by the current user
	-G file 		Checks if file exists and the default group is the same as the current user
	file1 -nt file2 	Checks if file1 is newer than file2
	file1 -ot file2 	Checks if file1 is older than file2
	----------------------------------------
	- Compound testing
	[ condition1 ] && [ condition2 ]
	[ condition1 ] || [ condition2 ]
+ Double parentheses (( )) for mathematical expressions
	(( expression ))
	-----------------------------------
	#!/bin/bash
	# using double parenthesis
	#
	val1=10
	#
	if (( $val1 ** 2 > 90 ))
	then
	   (( val2 = $val1 ** 2 ))
	   echo "The square of $val1 is $val2"
	fi
+ Double brackets [[ ]] for string comparisons
	[[ expression ]]
	---------------------------------------
	if [[ $USER == t* ]]
	then
	   echo "Hello $USER"
	else
	   echo "Sorry, I do not know you"
	fi
+ Case:
	case variable in
	pattern1 | pattern2) commands1;;
	pattern3) commands2;;
	*) default commands;;
	esac
	------------------------------------
	#!/bin/bash
	# using the case command
	#
	case $USER in
	rich | barbara)
	   echo "Welcome, $USER"
	   echo "Please enjoy your visit";;
	testing)
	   echo "Special testing account";;
	jessica)
	   echo "Do not forget to log off when you're done";;
	*)
	   echo "Sorry, you are not allowed here";;
	esac
+ For:
	for var in list
	do
	   commands
	done
	---------------------------
	list="Alabama Alaska Arizona Arkansas Colorado"

	for state in $list
	do
	   echo "Have you ever visited $state?"
	done
	----------------------------
	file="states"

	for state in $(cat $file)
	do
	   echo "Visit beautiful $state"
	done
	------------------------------
	- Changing the field separator
	A space
	A tab: \t
	A newline: \n
	- IFS defines a list of characters the bash shell uses as field separators
	- More than one IFS charater:
	IFS=$'\n':;" ('\n or : or ; or ")
	--------------------------------------
	file="states"

	IFS=$'\n'

	for state in $(cat $file)
	do
	   echo "Visit beautiful $state"
	done
	----------------------------------------------
	- C styles:
	for (( variable assignment ; condition ; iteration process ))
	----------------------------------------------
	#!/bin/bash
	# testing the C-style for loop

	for (( i=1; i <= 10; i++ ))
	do
	   echo "The next number is $i"
	done
+ While:
	while test command
	do
	   other commands
	done
	--------------------------------
	var1=10
	while [ $var1 -gt 0 ]
	do
	   echo $var1
	   var1=$[ $var1 - 1 ]
	done
+ Until:
	until test commands
	do
	   other commands
	done
	-------------------------------------
	#!/bin/bash
	# using the until command
	
	var1=100

	until [ $var1 -eq 0 ]
	do
	   echo $var1
	   var1=$[ $var1 - 25 ]
	done
	$ ./test12
	100
	75
	50
	25
+ Processing the output of a Loop
	#!/bin/bash
	# redirecting the for output to a file

	for (( a = 1; a < 10; a++ ))
	do
	   echo "The number is $a"
	done > test23.txt
	echo "The command is finished."

	$ ./test23
	The command is finished.
	$ cat test23.txt
	The number is 1
	The number is 2
	The number is 3
	The number is 4
	The number is 5
	The number is 6
	The number is 7
	The number is 8
	The number is 9
---------------------------------------------------------------------
* Handling user input
---------------------------------------------------------------------
+ Passing Parameters:
	- With $0 being the script’s name, $1 being the first parameter, $2 being the second parameter, and so on, up to $9 for the ninth parameter.
	----------------------------
	#!/bin/bash
	# testing two command line parameters
	#
	total=$[ $1 * $2 ]
	echo The first parameter is $1.
	echo The second parameter is $2.
	echo The total value is $total.
	$
	$ ./test2.sh 2 5
	The first parameter is 2.
	The second parameter is 5.
	The total value is 10.
	-----------------------------------
	- If your script needs more than nine command line parameters, you can continue, but the variable names change slightly. After the ninth variable, you must use braces around the variable number, such as ${10}
	------------------------------------
	#!/bin/bash
	# handling lots of parameters
	#
	total=$[ ${10} * ${11} ]
	echo The tenth parameter is ${10}
	echo The eleventh parameter is ${11}
	echo The total is $total
	$
	$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12
	The tenth parameter is 10
	The eleventh parameter is 11
	The total is 110
	$
+ Counting parameters
	- The special $# variable contains the number of command line parameters included when the script was run
	---------------------------------------------
	#!/bin/bash
	# getting the number of parameters
	#
	echo There were $# parameters supplied.
	$
	$ ./test8.sh
	There were 0 parameters supplied.
	$
	$ ./test8.sh 1 2 3 4 5
	There were 5 parameters supplied.
	$
	$ ./test8.sh 1 2 3 4 5 6 7 8 9 10
	There were 10 parameters supplied.
	$
	$ ./test8.sh "Rich Blum"
	There were 1 parameters supplied.
	$
+ Grabbing all the data (Lay tat ca du lieu)
	- The $* variable takes all the parameters supplied on the command line as a single word.
	- The $@ variable, on the other hand, takes all the parameters supplied on the command line as separate words in the same string.
	--------------------------------------------------
	#!/bin/bash
	# testing $* and $@
	#
	echo
	count=1
	#
	for param in "$*"
	do
	   echo "\$* Parameter #$count = $param"
	   count=$[ $count + 1 ]
	done
	#
	echo
	count=1
	#
	for param in "$@"
	do
	   echo "\$@ Parameter #$count = $param"
	   count=$[ $count + 1 ]
	done
	$
	$ ./test12.sh rich barbara katie jessica

	$* Parameter #1 = rich barbara katie jessica

	$@ Parameter #1 = rich
	$@ Parameter #2 = barbara
	$@ Parameter #3 = katie
	$@ Parameter #4 = jessica
	$
+ Shift:
	#!/bin/bash
	# demonstrating the shift command
	echo
	count=1
	while [ -n "$1" ]
	do
	   echo "Parameter #$count = $1"
	   count=$[ $count + 1 ]
	   shift
	done
	$
	$ ./test13.sh rich barbara katie jessica

	Parameter #1 = rich
	Parameter #2 = barbara
	Parameter #3 = katie
	Parameter #4 = jessica
	$
+ Options:
	#!/bin/bash
	# extracting command line options as parameters
	#
	echo
	while [ -n "$1" ]
	do
	   case "$1" in
	     -a) echo "Found the -a option" ;;
	     -b) echo "Found the -b option" ;;
	     -c) echo "Found the -c option" ;;
	     *) echo "$1 is not an option" ;;
	   esac
	   shift
	done
	$
	$ ./test15.sh -a -b -c -d
	
	Found the -a option
	Found the -b option
	Found the -c option
	-d is not an option
	$
	--------------------------------------------------------
	#!/bin/bash
	# extracting options and parameters
	echo
	while [ -n "$1" ]
	do
	   case "$1" in
	      -a) echo "Found the -a option" ;;
	      -b) echo "Found the -b option";;
	      -c) echo "Found the -c option" ;;
	      --) shift
	          break ;;
	       *) echo "$1 is not an option";;
	   esac
	   shift
	done
	#
	count=1
	for param in $@
	do
	   echo "Parameter #$count: $param"
	   count=$[ $count + 1 ]
	done
	$

	./test16.sh -c -a -b test1 test2 test3

	Found the -c option
	Found the -a option
	Found the -b option
	test1 is not an option
	test2 is not an option
	test3 is not an option
	$

	./test16.sh -c -a -b -- test1 test2 test3

	Found the -c option
	Found the -a option
	Found the -b option
	Parameter #1: test1
	Parameter #2: test2
	Parameter #3: test3
	$
+ Read: accepts input either from standar input (such as from the keyboard) or from another file descriptor.
	#!/bin/bash
	# testing the read command
	#
	echo -n "Enter your name: "
	read name
	echo "Hello $name, welcome to my program. "
	#
	$
	$ ./test21.sh
	Enter your name: Rich Blum
	Hello Rich Blum, welcome to my program.
	$
	-------------------------------------------
	- The read command includes the -p option, which allows you to specify a prompt directly in the read command line:
	--------------------------------------------------
	#!/bin/bash
	# testing the read -p option
	#
	read -p "Please enter your age: " age
	days=$[ $age * 365 ]
	echo "That makes you over $days days old! "
	#
	$
	$ ./test22.sh
	Please enter your age: 10
	That makes you over 3650 days old!
	$
	--------------------------------------------------
	#!/bin/bash
	# entering multiple variables
	#
	read -p "Enter your name: " first last
	echo "Checking data for $last, $first..."
	$
	$ ./test23.sh
	Enter your name: Rich Blum
	Checking data for Blum, Rich...
	$
---------------------------------------------------------------------
* Presenting Data
---------------------------------------------------------------------
+ Linux standard file descriptors
	File Descriptor 	Abbreviation 	Description
		0 		STDIN 		Standard input
		1 		STDOUT 		Standard output
		2 		STDERR 		Standard error
	----------------------------------------------------
	$ ls -al badfile 2> test4
	$ cat test4
	ls: cannot access badfile: No such file or directory
	$
	---------------------------------------------------------
	$ ls -al test badtest test2 2> test5
	-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2
	$ cat test5
	ls: cannot access test: No such file or directory
	ls: cannot access badtest: No such file or directory
	$
	--------------------------------------------------------
	$ ls -al test test2 test3 badtest 2> test6 1> test7
	$ cat test6
	ls: cannot access test: No such file or directory
	ls: cannot access badtest: No such file or directory
	$ cat test7
	-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2
	-rw-rw-r-- 1 rich rich
	0 2014-10-16 11:33 test3
	$
	-------------------------------------------------------
	- if you want, you can redirect both STDERR and STDOUT output to the same output file. The bash shell provides a special redirection symbol just for this purpose, the &> symbol:
	$ ls -al test test2 test3 badtest &> test7
	$ cat test7
	ls: cannot access test: No such file or directory
	ls: cannot access badtest: No such file or directory
	-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2
	-rw-rw-r-- 1 rich rich
	0 2014-10-16 11:33 test3
	$
+ Redirecting output in scripts
	$ cat test8
	#!/bin/bash
	# testing STDERR messages
	echo "This is an error" >&2
	echo "This is normal output"
	$
	$ ./test8
	This is an error
	This is normal output
	$
	$ ./test8 2> test9
	This is normal output
	$ cat test9
	This is an error
	$
	------------------------------------------
	$ cat test10
	#!/bin/bash
	# redirecting all output to a file
	exec 1>testout

	echo "This is a test of redirecting all output"
	echo "from a script to another file."
	echo "without having to redirect every individual line"
	$ ./test10
	$ cat testout
	This is a test of redirecting all output
	from a script to another file.
	without having to redirect every individual line
	$
	--------------------------------------------------
	$ cat test11
	#!/bin/bash
	# redirecting output to different locations

	exec 2>testerror

	echo "This is the start of the script"
	echo "now redirecting all output to another location"

	exec 1>testout

	echo "This output should go to the testout file"
	echo "but this should go to the testerror file" >&2
	$
	$ ./test11
	This is the start of the script
	now redirecting all output to another location
	$ cat testout
	This output should go to the testout file
	$ cat testerror
	but this should go to the testerror file
	$ 
+ Redirecting input in scripts:
	$ cat test12
	#!/bin/bash
	# redirecting file input

	exec 0< testfile
	count=1

	while read line
	do
	   echo "Line #$count: $line"
	   count=$[ $count + 1 ]
	done
	$ ./test12
	Line #1: This is the first line.
	Line #2: This is the second line.
	Line #3: This is the third line.
	$
+ Creating output file descriptors:
	$ cat test13
	#!/bin/bash
	# using an alternative file descriptor

	exec 3>test13out

	echo "This should display on the monitor"
	echo "and this should be stored in the file" >&3
	echo "Then this should be back on the monitor"
	$ ./test13
	This should display on the monitor
	Then this should be back on the monitor
	$ cat test13out
	and this should be stored in the file
	$
+ Creating a read/write file descriptor:
	$ cat test16
	#!/bin/bash
	# testing input/output file descriptor

	exec 3<> testfile
	read line <&3
	echo "Read: $line"
	echo "This is a test line" >&3
	$ cat testfile
	This is the first line.
	This is the second line.
	This is the third line.
	$ ./test16
	Read: This is the first line.
	$ cat testfile
	This is the first line.
	This is a test line
	ine.
	This is the third line.
	$
---------------------------------------------------------------------
* Creating functions
---------------------------------------------------------------------
+ Creating a function:
	function name {
	    commands
	}
	----------------------------------
	name() {
	commands
	}
	--------------------------------------
	$ cat test1
	#!/bin/bash
	# using a function in a script

	function func1 {
	   echo "This is an example of a function"
	}

	count=1
	while [ $count -le 5 ]
	do
	   func1
	   count=$[ $count + 1 ]
	done

	echo "This is the end of the loop"
	func1
	echo "Now this is the end of the script"
	$
	$ ./test1
	This is an example of a function
	This is an example of a function
	This is an example of a function
	This is an example of a function
	This is an example of a function
	This is the end of the loop
	This is an example of a function
	Now this is the end of the script
	$
+ Returning a value:
	$ cat test5b
	#!/bin/bash
	# using the echo to return a value

	function dbl {
	   read -p "Enter a value: " value
	   echo $[ $value * 2 ]
	}

	result=$(dbl)
	echo "The new value is $result"
	$
	$ ./test5b
	Enter a value: 200
	The new value is 400
	$
	$ ./test5b
	Enter a value: 1000
	The new value is 2000
	$
+ Using variables in functions:
	$ cat test6
	#!/bin/bash
	# passing parameters to a function

	function addem {
	   if [ $# -eq 0 ] || [ $# -gt 2 ]
	   then
	      echo -1
	   elif [ $# -eq 1 ]
	   then 
	      echo $[ $1 + $1 ]
	   else
	      echo $[ $1 + $2 ]
	   fi
	}

	echo -n "Adding 10 and 15: "
	value=$(addem 10 15)
	echo $value
	echo -n "Let's try adding just one number: "
	value=$(addem 10)
	echo $value
	echo -n "Now trying adding no numbers: "
	value=$(addem)
	echo $value
	echo -n "Finally, try adding three numbers: "
	value=$(addem 10 15 20)
	echo $value
	$
	$ ./test6
	Adding 10 and 15: 25
	Let's try adding just one number: 20
	Now trying adding no numbers: -1
	Finally, try adding three numbers: -1
	$
	-----------------------------------------------
	$ cat test7
	#!/bin/bash
	# trying to access script parameters inside a function

	function func7 {
	   echo $[ $1 * $2 ]
	}

	if [ $# -eq 2 ]
	then
	   value=$(func7 $1 $2)
	   echo "The result is $value"
	else
	   echo "Usage: badtest1 a b"
	fi
	$
	$ ./test7
	Usage: badtest1 a b
	$ ./test7 10 15
	The result is 150
	$
+ Handling variables in a function:
	- Functions use two types of variables:
		Global
		Local
	- Global variables are variables that are valid anywhere within the shell script.
	-----------------------------------------------------------
	$ cat test8
	#!/bin/bash
	# using a global variable to pass a value

	function dbl {
	   value=$[ $value * 2 ]
	}

	read -p "Enter a value: " value
	dbl
	echo "The new value is: $value"
	$
	$ ./test8
	Enter a value: 450
	The new value is: 900
	$
	--------------------------------------------------------------
	- $ cat badtest2
	#!/bin/bash
	# demonstrating a bad use of variables

	function func1 {
	   temp=$[ $value + 5 ]
	   result=$[ $temp * 2 ]
	}

	temp=4
	value=6

	func1
	echo "The result is $result"
	if [ $temp -gt $value ]
	then
	   echo "temp is larger"
	else
	   echo "temp is smaller"
	fi
	$
	$ ./badtest2
	The result is 22
	temp is larger
	$
	----------------------------------------------------------------------
	- Instead of using global variables in functions, any variables that the function uses internally can be declared as local variables. To do that, just use the local keyword in front of the variable declaration:
	local temp
	--------------------------------------------------------------------------------
	$ cat test9
	#!/bin/bash
	# demonstrating the local keyword

	function func1 {
	   local temp=$[ $value + 5 ]
	   result=$[ $temp * 2 ]
	}

	temp=4
	value=6

	func1
	echo "The result is $result"
	if [ $temp -gt $value ]
	then
 	   echo "temp is larger"
	else
	   echo "temp is smaller"
	fi
	$
	$ ./test9
	The result is 22
	temp is smaller
	$
+ Array Variables:
	$ cat test10
	#!/bin/bash
	# array variable to function test

	function testit {
	   local newarray
	   newarray=(;'echo "$@"')
	   echo "The new array value is: ${newarray[*]}"
	}

	myarray=(1 2 3 4 5)
	echo "The original array is ${myarray[*]}"
	testit ${myarray[*]}
	$
	$ ./test10
	The original array is 1 2 3 4 5
	The new array value is: 1 2 3 4 5
	$
	----------------------------------------------------
	$ cat test11
	#!/bin/bash
	# adding values in an array

	function addarray {
	   local sum=0
	   local newarray
	   newarray=($(echo "$@"))
	   for value in ${newarray[*]}
	   do
	      sum=$[ $sum + $value ]
	   done
	   echo $sum
	}

	myarray=(1 2 3 4 5)
	echo "The original array is: ${myarray[*]}"
	arg1=$(echo ${myarray[*]})
	result=$(addarray $arg1)
	echo "The result is $result"
	$
	$ ./test11
	The original array is: 1 2 3 4 5
	The result is 15
	$
+ Function recursion:
	$ cat test13
	#!/bin/bash
	# using recursion

	function factorial {
	   if [ $1 -eq 1 ]
	   then
	      echo 1
	   else
	      local temp=$[ $1 - 1 ]
	      local result=$(factorial $temp)
	      echo $[ $result * $1 ]
	   fi
	}

	read -p "Enter value: " value
	result=$(factorial $value)
	echo "The factorial of $value is: $result"
	$
	$ ./test13
	Enter value: 5
	The factorial of 5 is: 120
	$
+ Creating a library
	$ cat myfuncs
	# my script functions

	function addem {
	   echo $[ $1 + $2 ]
	}

	function multem {
	   echo $[ $1 * $2 ]
	}

	function divem {
	   if [ $2 -ne 0 ]
	   then
	      echo $[ $1 / $2 ]
	   else
	      echo -1
	   fi
	}
	$
	-----------------------------------
	$ cat test14
	#!/bin/bash
	# using functions defined in a library file

	. ./myfuncs

	value1=10
	value2=5
	result1=$(addem $value1 $value2)
	result2=$(multem $value1 $value2)
	result3=$(divem $value1 $value2)
	echo "The result of adding them is: $result1"
	echo "The result of multiplying them is: $result2"
	echo "The result of dividing them is: $result3"
	$
	$ ./test14
	The result of adding them is: 15
	The result of multiplying them is: 50
	The result of dividing them is: 2
	$
---------------------------------------------------------------------
* Sed
---------------------------------------------------------------------
+ The sed editor is called a stream editor, as opposed to a normal interactive text editor. In an interactive text editor, such as vim, you interactively use keyboard commands to insert, delete, or
replace text in the data. A stream editor edits a stream of data based on a set of rules you supply ahead of time, before the editor processes the data.
+ Here’s the format for using the sed command:
	sed options script file
+ Sed options:	
	-e script 	Adds commands specified in the script to the commands run while processing the input
	-f file 	Adds the commands specifi ed in the fi le to the commands run while processing the input
	-n 		Doesn’t produce output for each command, but waits for the print command
	-----------------------------------------------------------
	$ echo "This is a test" | sed 's/test/big test/'
	This is a big test
	$
	------------------------------------------------------------
	$ cat data1.txt
	The quick brown fox jumps over the lazy dog.
	The quick brown fox jumps over the lazy dog.
	The quick brown fox jumps over the lazy dog.
	The quick brown fox jumps over the lazy dog.
	$
	$ sed 's/dog/cat/' data1.txt
	The quick brown fox jumps over the lazy cat.
	The quick brown fox jumps over the lazy cat.
	The quick brown fox jumps over the lazy cat.
	The quick brown fox jumps over the lazy cat.
	$
	---------------------------------------------------------------
	$ sed -e 's/brown/green/; s/dog/cat/' data1.txt
	The quick green fox jumps over the lazy cat.
	The quick green fox jumps over the lazy cat.
	The quick green fox jumps over the lazy cat.
	The quick green fox jumps over the lazy cat.
	$
	-------------------------------------------------------------
	$ sed -e '
	> s/brown/green/
	> s/fox/elephant/
	> s/dog/cat/' data1.txt
	The quick green elephant jumps over the lazy cat.
	The quick green elephant jumps over the lazy cat.
	The quick green elephant jumps over the lazy cat.
	The quick green elephant jumps over the lazy cat.
	$
+ Reading editor commands from a file:
	$ cat script1.sed
	s/brown/green/
	s/fox/elephant/
	s/dog/cat/
	$
	$ sed -f script1.sed data1.txt
	The quick green elephant jumps over the lazy cat.
	The quick green elephant jumps over the lazy cat.
	The quick green elephant jumps over the lazy cat.
	The quick green elephant jumps over the lazy cat.
---------------------------------------------------------------------
* Gawk
---------------------------------------------------------------------
+ Here’s the basic format of the gawk program:
	gawk options program file
+ Gawk options:
	-F fs 		Specifies a file separator for delineating data fields in a line
	-f file 	Specifies a file name to read the program from
	-v var=value 	Defines a variable and default value used in the gawk program
	-mf N 		Specifies the maximum number of fields to process in the data file
	-mr N 		Specifies the maximum record size in the data file
	-W keyword 	Specifies the compatibility mode or warning level for gawk
+ Using data field variables:
	- $0 represents the entire line of text.
	- $1 represents the first data field in the line of text.
	- $2 represents the second data field in the line of text.
	- $n represents the nth data field in the line of text.
	-----------------------------------------------------
	$ cat data2.txt
	One line of test text.
	Two lines of test text.
	Three lines of test text.
	$
	$ gawk '{print $1}' data2.txt
	One
	Two
	Three
	$
	-----------------------------------------------------
	- If you’re reading a file that uses a different field separation character, you can specify it by using the -F option: (Dau :)
	$ gawk -F: '{print $1}' /etc/passwd
	root
	bin
	daemon
	adm
	lp
	sync
	shutdown
	halt
	mail
	[...]
+ Using multiple commands:
	$ gawk '{
	> $4="Christine"
	> print $0}'
	My name is Rich
	My name is Christine
	$
+ Reading the program from a file
	$ cat script3.gawk
	{
	text = "'s home directory is "
	print $1 text $6
	}
	$
	$ gawk -F: -f script3.gawk /etc/passwd
	root's home directory is /root
	bin's home directory is /bin
	daemon's home directory is /sbin
	adm's home directory is /var/adm
	lp's home directory is /var/spool/lpd
	[...]
	Christine's home directory is /home/Christine
	Samantha's home directory is /home/Samantha
	Timothy's home directory is /home/Timothy
	$
+ Running scripts before processing data:
	$ cat data3.txt
	Line 1
	Line 2
	Line 3
	$
	$ gawk 'BEGIN {print "The data3 File Contents:"}
	> {print $0}' data3.txt
	The data3 File Contents:
	Line 1
	Line 2
	Line 3
	$
+ Running scripts after processing data:
	$ gawk 'BEGIN {print "The data3 File Contents:"}
	> {print $0}
	> END {print "End of File"}' data3.txt
	The data3 File Contents:
	Line 1
	Line 2
	Line 3
	End of File
	$
	---------------------------------------------------
	$ cat script4.gawk
	BEGIN {
	print "The latest list of users and shells"
	print " UserID \t Shell"
	print "-------- \t -------"
	FS=":"
	}

	{
	print $1 "	\t " $7
	}

	END {
	print "This concludes the listing"
	}
	$

	$ gawk -f script4.gawk /etc/passwd
	The latest list of users and shells
	UserID		Shell
	--------	-------
	root		/bin/bash
	bin		/sbin/nologin
	daemon		/sbin/nologin
	[...]
	Christine	/bin/bash
	mysql		/bin/bash
	Samantha	/bin/bash
	Timothy		/bin/bash
	This concludes the listing
	$
---------------------------------------------------------------------
* Commanding at the sed Editor Basics:
---------------------------------------------------------------------
+ Substituting flags:
	s/pattern/replacement/flags
	- A number, indicating the pattern occurrence for which new text should be substituted
	- g, indicating that new text should be substituted for all occurrences of the existing text
	- p, indicating that the contents of the original line should be printed
	- w file, which means to write the results of the substitution to a file
	----------------------------------------------------------
	$ cat data4.txt
	This is a test of the test script.
	This is the second test of the test script.
	$
	$ sed 's/test/trial/2' data4.txt
	This is a test of the trial script.
	This is the second test of the trial script.
	$
	$ sed 's/test/trial/g' data4.txt
	This is a trial of the trial script.
	This is the second trial of the trial script.
	$
	-----------------------------------------------------------
	$ sed 's/test/trial/w test.txt' data5.txt
	This is a trial line.
	This is a different line.
	$
	$ cat test.txt
	This is a trial line.
	$
+ Using address:
There are two forms of line addressing in the sed editor:
■ A numeric range of lines
■ A text pattern that fi lters out a line
Both forms use the same format for specifying the address:
	[address] command
You can also group more than one command together for a specifi c address:
	address {
  	   command1
	   command2
	   command3
	}
	--------------------------------------------------
	$ sed '2s/dog/cat/' data1.txt
	The quick brown fox jumps over the lazy dog
	The quick brown fox jumps over the lazy cat
	The quick brown fox jumps over the lazy dog
	The quick brown fox jumps over the lazy dog
	--------------------------------------------------
	$ sed '2,3s/dog/cat/' data1.txt
	The quick brown fox jumps over the lazy dog
	The quick brown fox jumps over the lazy cat
	The quick brown fox jumps over the lazy cat
	The quick brown fox jumps over the lazy dog
	--------------------------------------------------
	$ sed '2,$s/dog/cat/' data1.txt
	The quick brown fox jumps over the lazy dog
	The quick brown fox jumps over the lazy cat
	The quick brown fox jumps over the lazy cat
	The quick brown fox jumps over the lazy cat
+ Using text pattern filters:
	/pattern/command
	----------------------------------------
	$ grep Samantha /etc/passwd
	Samantha:x:502:502::/home/Samantha:/bin/bash
	$
	$ sed '/Samantha/s/bash/csh/' /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	bin:x:1:1:bin:/bin:/sbin/nologin
	[...]
	Christine:x:501:501:Christine B:/home/Christine:/bin/bash
	Samantha:x:502:502::/home/Samantha:/bin/csh
	Timothy:x:503:503::/home/Timothy:/bin/bash
	$
+ Grouping commands
	$ sed '2{
	> s/fox/elephant/
	> s/dog/cat/
	> }' data1.txt
	The quick brown fox jumps over the lazy dog
	The quick brown elephant jumps over the lazy cat
	The quick brown fox jumps over the lazy dog
	The quick brown fox jumps over the lazy dog
	$
	---------------------------------------------
+ Deleting lines:
	$ cat data1.txt
	The quick brown fox
	The quick brown fox
	The quick brown fox
	The quick brown fox
	$
	$ sed 'd' data1.txt
	$
	---------------------------------------------------
	$ cat data6.txt
	This is line number 1.
	This is line number 2.
	This is line number 3.
	This is line number 4.
	$
	$ sed '3d' data6.txt
	This is line number 1.
	This is line number 2.
	This is line number 4.
	$
	---------------------------------------------------
	- You can also delete a range of lines using two text patterns:
	$ sed '/1/,/3/d' data6.txt
	This is line number 4.
	$
+ Inserting and appending text
■ The insert command (i) adds a new line before the specified line.
■ The append command (a) adds a new line after the specified line.
	sed '[address]command\
	new line'
	-------------------------------------------
	$ echo "Test Line 2" | sed 'i\Test Line 1'
	Test Line 1
	Test Line 2
	$
	---------------------------------------------
	$ echo "Test Line 2" | sed 'a\Test Line 1'
	Test Line 2
	Test Line 1
	$
	-------------------------------------------
	$ sed '3i\
	> This is an inserted line.' data6.txt
	This is line number 1.
	This is line number 2.
	This is an inserted line.
	This is line number 3.
	This is line number 4.
	$
	---------------------------------------------
	$ sed '$a\
	> This is a new line of text.' data6.txt
	This is line number 1.
	This is line number 2.
	This is line number 3.
	This is line number 4.
	This is a new line of text.
	$
+ Changing lines:
	$ sed '3c\
	> This is a changed line of text.' data6.txt
	This is line number 1.
	This is line number 2.
	This is a changed line of text.
	This is line number 4.
	$
	-------------------------------------
	$ sed '/number 3/c\
	> This is a changed line of text.' data6.txt
	This is line number 1.
	This is line number 2.
	This is a changed line of text.
	This is line number 4.
	$
	----------------------------------------
	$ cat data8.txt
	This is line number 1.
	This is line number 2.
	This is line number 3.
	This is line number 4.
	This is line number 1 again.
	This is yet another line.
	This is the last line in the file.
	$
	$ sed '/number 1/c\
	> This is a changed line of text.' data8.txt
	This is a changed line of text.
	This is line number 2.
	This is line number 3.
	This is line number 4.
	This is a changed line of text.
	This is yet another line.
	This is the last line in the file.
	$
+ Transforming characters:
	[address]y/inchars/outchars/
	--------------------------------------------------
	$ sed 'y/123/789/' data8.txt
	This is line number 7.
	This is line number 8.
	This is line number 9.
	This is line number 4.
	This is line number 7 again.
	This is yet another line.
	This is the last line in the file.
	$
	------------------------------------------------------
	$ echo "This 1 is a test of 1 try." | sed 'y/123/456/'
	This 4 is a test of 4 try.
	$
+ Printing lines:
	$ echo "this is a test" | sed 'p'
	this is a test
	this is a test
	$
	-----------------------------------------------
	$ cat data6.txt
	This is line number 1.
	This is line number 2.
	This is line number 3.
	This is line number 4.
	$
	$ sed -n '/number 3/p' data6.txt
	This is line number 3.
	$
	--------------------------------------------
	$ sed -n '2,3p' data6.txt
	This is line number 2.
	This is line number 3.
	$
	----------------------------------------------
	$ sed -n '/3/{
	> p
	> s/line/test/p
	> }' data6.txt
	This is line number 3.
	This is test number 3.
	$
+ Printing line numbers:
	$ cat data1.txt
	The quick brown fox jumps over the lazy dog.
	The quick brown fox jumps over the lazy dog.
	The quick brown fox jumps over the lazy dog.
	The quick brown fox jumps over the lazy dog.
	$
	$ sed '=' data1.txt
	1
	The quick brown fox jumps over the lazy dog.
	2
	The quick brown fox jumps over the lazy dog.
	3
	The quick brown fox jumps over the lazy dog.
	4
	The quick brown fox jumps over the lazy dog.
	-----------------------------------------------
	$ sed -n '/number 4/{
	> =
	> p
	> }' data6.txt
	4
	This is line number 4.
	$
+ Listing lines:
	$ cat data9.txt
	This	line	contains	tabs.
	$
	$ sed -n 'l' data9.txt
	This\tline\tcontains\ttabs.$
	$
+ Using files with sed:
	- Writing to a file:
		[address]w filename
	--------------------------------------------
	$ sed '1,2w test.txt' data6.txt
	This is line number 1.
	This is line number 2.
	This is line number 3.
	This is line number 4.
	$
	$ cat test.txt
	This is line number 1.
	This is line number 2.
	$
	---------------------------------------------
	$ cat data11.txt
	Blum, R		Browncoat
	McGuiness, A 	Alliance
	Bresnahan, C 	Browncoat
	Harken, C	Alliance
	$
	$ sed -n '/Browncoat/w Browncoats.txt' data11.txt
	$
	$ cat Browncoats.txt
	Blum, R		Browncoat
	Bresnahan, C 	Browncoat
	$
	------------------------------------------------
	- Reading data from a file
		[address]r filename
---------------------------------------------------------------------
* Regular Expressions 
---------------------------------------------------------------------
+ Defining BRE Patterns:
	- Plain text (In ra dong co noi dung phu hop voi pattern
	-----------------------------------------------------------
	$ echo "This is a test" | sed -n '/test/p'
	This is a test
	$ echo "This is a test" | sed -n '/trial/p'
	$
	$ echo "This is a test" | gawk '/test/{print $0}'
	This is a test
	$ echo "This is a test" | gawk '/trial/{print $0}'
	$
	--------------------------------------------------------
	$ echo "This is a test" | sed -n '/this/p'
	$
	$ echo "This is a test" | sed -n '/This/p'
	This is a test
	$
	---------------------------------------------------------
	$ echo "The books are expensive" | sed -n '/book/p'
	The books are expensive
	$
	--------------------------------------------------------
	$ echo "The book is expensive" | sed -n '/books/p'
	$
	-------------------------------------------------------
	$ echo "This is line number 1" | sed -n '/ber 1/p'
	This is line number 1
	$
	-------------------------------------------------------
	$ cat data1
	This is a normal line of text.
	This is a line with too many spaces.
	$ sed -n '/ /p' data1
	This is a line with too many spaces.
	$
	--------------------------------------------------------
	- Special characters: .*[]^${}\+?|()
	-------------------------------------------------------
	$ cat data2
	The cost is $4.00
	$ sed -n '/\$/p' data2
	The cost is $4.00
	$
	--------------------------------------------------------
	$ echo "\ is a special character" | sed -n '/\\/p'
	\ is a special character
	$
	--------------------------------------------------------
	$ echo "3 / 2" | sed -n '/\//p'
	3 / 2
	$
	-------------------------------------------------------
	- Starting at the beginning: ^
	--------------------------------------------------------
	$ echo "The book store" | sed -n '/^book/p'
	$
	$ echo "Books are great" | sed -n '/^Book/p'
	Books are great
	$
	----------------------------------------------------------
	$ cat data3
	This is a test line.
	this is another test line.
	A line that tests this feature.
	Yet more testing of this
	$ sed -n '/^this/p' data3
	this is another test line.
	$
	--------------------------------------------------------
	- Looking for the ending: $
	------------------------------------------------------
	$ echo "This is a good book" | sed -n '/book$/p'
	This is a good book
	$ echo "This book is good" | sed -n '/book$/p'
	$
	-----------------------------------------------------
	- Combining anchors: ^ and $
	------------------------------------------------------
	$ cat data4
	this is a test of using both anchors
	I said this is a test
	this is a test
	I'm sure this is a test.
	$ sed -n '/^this is a test$/p' data4
	this is a test
	$
	-----------------------------------------------------
	$ cat data5
	This is one test line.

	This is another test line.
	$ sed '/^$/d' data5
	This is one test line.
	This is another test line.
	$
	----------------------------------------------------
	- The dot character:
	----------------------------------------------------
	$ cat data6
	This is a test of a line.
	The cat is sleeping.
	That is a very nice hat.
	This test is at line four.
	at ten o'clock we'll go home.
	$ sed -n '/.at/p' data6
	The cat is sleeping.
	That is a very nice hat.
	This test is at line four.
	$
	---------------------------------------------------
	- Character classes:
	---------------------------------------------------
	$ sed -n '/[ch]at/p' data6
	The cat is sleeping.
	That is a very nice hat.
	$
	---------------------------------------------------
	$ echo "Yes" | sed -n '/[Yy][Ee][Ss]/p'
	Yes
	$ echo "yEs" | sed -n '/[Yy][Ee][Ss]/p'
	yEs
	$ echo "yeS" | sed -n '/[Yy][Ee][Ss]/p'
	yeS
	$
	---------------------------------------------------
	$ cat data7
	This line doesn't contain a number.
	This line has 1 number on it.
	This line a number 2 on it.
	This line has a number 4 on it.
	$ sed -n '/[0123]/p' data7
	This line has 1 number on it.
	This line a number 2 on it.
	$
	---------------------------------------------------
	$ cat data9
	I need to have some maintenence done on my car.
	I'll pay that in a seperate invoice.
	After I pay for the maintenance my car will be as good as new.
	$ sed -n '
	/maint[ea]n[ae]nce/p
	/sep[ea]r[ea]te/p
	' data9
	I need to have some maintenence done on my car.
	I'll pay that in a seperate invoice.
	After I pay for the maintenance my car will be as good as new.
	$
	---------------------------------------------------
	- Using ranges:
	----------------------------------------------------
	$ cat data8
	60633
	46201
	223001
	4353
	22203
	$ sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8
	60633
	46201
	45902
	$
	-----------------------------------------------------
	The character class allows the ranges a through c, and h through m to appear before the at text. This range would reject any letters between d and g:
	$ echo "I'm getting too fat." | sed -n '/[a-ch-m]at/p'
	$
	---------------------------------------------------
	- Special character classes:
	-----------------------------------------------------
	[[:alpha:]] 	Matches any alphabetical character, either upper or lower case
	[[:alnum:]] 	Matches any alphanumeric character 0–9, A–Z, or a–z
	[[:blank:]] 	Matches a space or Tab character
	[[:digit:]] 	Matches a numerical digit from 0 through 9
	[[:lower:]] 	Matches any lowercase alphabetical character a–z
	[[:print:]] 	Matches any printable character
	[[:punct:]] 	Matches a punctuation character
	[[:space:]] 	Matches any whitespace character: space, Tab, NL, FF, VT, CR
	[[:upper:]] 	Matches any uppercase alphabetical character A–Z
	-------------------------------------------------------------
	$ echo "abc" | sed -n '/[[:digit:]]/p'
	$
	$ echo "abc" | sed -n '/[[:alpha:]]/p'
	abc
	$ echo "abc123" | sed -n '/[[:digit:]]/p'
	abc123
	$ echo "This is, a test" | sed -n '/[[:punct:]]/p'
	This is, a test
	$ echo "This is a test" | sed -n '/[[:punct:]]/p'
	$
	----------------------------------------------------------------
	- The asterisk: *
	--------------------------------------------------------------
	$ echo "ik" | sed -n '/ie*k/p'
	ik
	$ echo "iek" | sed -n '/ie*k/p'
	iek
	$ echo "ieek" | sed -n '/ie*k/p'
	ieek
	$ echo "ieeek" | sed -n '/ie*k/p'
	ieeek
	$ echo "ieeeek" | sed -n '/ie*k/p'
	ieeeek
	------------------------------------------------------------
	$ echo "I ate a potatoe with my lunch." | sed -n '/potatoe*/p'
	I ate a potatoe with my lunch.
	$ echo "I ate a potato with my lunch." | sed -n '/potatoe*/p'
	I ate a potato with my lunch.
	$
	-----------------------------------------------------------
	$ echo "this is a regular pattern expression" | sed -n '
	> /regular.*expression/p'
	this is a regular pattern expression
	$
	------------------------------------------------------------
	$ echo "bt" | sed -n '/b[ae]*t/p'
	bt
	$ echo "bat" | sed -n '/b[ae]*t/p'
	bat
	$ echo "bet" | sed -n '/b[ae]*t/p'
	bet
	$ echo "btt" | sed -n '/b[ae]*t/p'
	btt
	$
	$ echo "baat" | sed -n '/b[ae]*t/p'
	baat
	$ echo "baaeeet" | sed -n '/b[ae]*t/p'
	baaeeet
	$ echo "baeeaeeat" | sed -n '/b[ae]*t/p'
	baeeaeeat
	$ echo "baakeeet" | sed -n '/b[ae]*t/p'
	$
+ Extended regular expressions:
	- The question mark:
	--------------------------------------------------------------
	$ echo "bt" | gawk '/be?t/{print $0}'
	bt
	$ echo "bet" | gawk '/be?t/{print $0}'
	bet
	$ echo "beet" | gawk '/be?t/{print $0}'
	beet
	$ echo "beeet" | gawk '/be?t/{print $0}'
	beeet
	--------------------------------------------------------
	$ echo "bt" | gawk '/b[ae]?t/{print $0}'
	bt
	$ echo "bat" | gawk '/b[ae]?t/{print $0}'
	bat
	$ echo "bot" | gawk '/b[ae]?t/{print $0}'
	bot
	$ echo "bet" | gawk '/b[ae]?t/{print $0}'
	bet
	$ echo "baet" | gawk '/b[ae]?t/{print $0}'
	$
	$ echo "beat" | gawk '/b[ae]?t/{print $0}'
	$
	$ echo "beet" | gawk '/b[ae]?t/{print $0}'
	$
	If zero or one character from the character class appears, the pattern match passes. However, if both characters appear, or if one of the characters appears twice, the pattern match fails.
	-----------------------------------------------------------------
	- The plus sign:
	-----------------------------------------------------------------
	$ echo "beeet" | gawk '/be+t/{print $0}'
	beeet
	$ echo "beet" | gawk '/be+t/{print $0}'
	beet
	$ echo "bet" | gawk '/be+t/{print $0}'
	bet
	$ echo "bt" | gawk '/be+t/{print $0}'
	$
	----------------------------------------------------------------
	$ echo "bt" | gawk '/b[ae]+t/{print $0}'
	$
	$ echo "bat" | gawk '/b[ae]+t/{print $0}'
	bat
	$ echo "bet" | gawk '/b[ae]+t/{print $0}'
	bet
	$ echo "beat" | gawk '/b[ae]+t/{print $0}'
	beat
	$ echo "beet" | gawk '/b[ae]+t/{print $0}'
	beet
	$ echo "beeat" | gawk '/b[ae]+t/{print $0}'
	beeat
	$
	----------------------------------------------------------------
	- Using braces: 
	- Cause: By default, the gawk program doesn’t recognize regular expression intervals. You must specify the --re-interval command line option for the gawk program to recognize regular expression intervals.
	------------------------------------------------------------------
	$ echo "bt" | gawk --re-interval '/be{1}t/{print $0}'
	$
	$ echo "bet" | gawk --re-interval '/be{1}t/{print $0}'
	bet
	$ echo "beet" | gawk --re-interval '/be{1}t/{print $0}'
	$
	------------------------------------------------------------------
	$ echo "bt" | gawk --re-interval '/be{1,2}t/{print $0}'
	$	
	$ echo "bet" | gawk --re-interval '/be{1,2}t/{print $0}'
	bet	
	$ echo "beet" | gawk --re-interval '/be{1,2}t/{print $0}'
	beet	
	$ echo "beeet" | gawk --re-interval '/be{1,2}t/{print $0}'
	$
	----------------------------------------------------------------
	- The pipe symbol:
	expr1|expr2|...
	----------------------------------------------------------------
	$ echo "The cat is asleep" | gawk '/cat|dog/{print $0}'
	The cat is asleep
	$ echo "The dog is asleep" | gawk '/cat|dog/{print $0}'
	The dog is asleep
	$ echo "The sheep is asleep" | gawk '/cat|dog/{print $0}'
	$
	---------------------------------------------------------------
	- Grouping:
	---------------------------------------------------------------
	$ echo "cat" | gawk '/(c|b)a(b|t)/{print $0}'
	cat
	$ echo "cab" | gawk '/(c|b)a(b|t)/{print $0}'
	cab
	$ echo "bat" | gawk '/(c|b)a(b|t)/{print $0}'
	bat
	$ echo "bab" | gawk '/(c|b)a(b|t)/{print $0}'
	bab
	$ echo "tab" | gawk '/(c|b)a(b|t)/{print $0}'
	$
	$ echo "tac" | gawk '/(c|b)a(b|t)/{print $0}'
	$
+ Validating a phone number:
	$ cat isphone
	#!/bin/bash
	# script to filter out bad phone numbers
	gawk --re-interval '/^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}/{print $0}'
	$
	$ echo "317-555-1234" | ./isphone
	317-555-1234
	$ echo "000-555-1234" | ./isphone
	$ echo "312 555-1234" | ./isphone
	312 555-1234
	$
	-------------------------------------------------------------------------------
	$ cat phonelist
	000-000-0000
	123-456-7890
	212-555-1234
	(317)555-1234
	(202) 555-9876
	33523
	1234567890
	234.123.4567
	$ cat phonelist | ./isphone
	212-555-1234
	(317)555-1234
	(202) 555-9876
	234.123.4567
	$
---------------------------------------------------------------------
* Advanced sed 
---------------------------------------------------------------------
+ Looking at multiline commands:
	- Combining lines of text:
	---------------------------------------------------------
	$ cat data2.txt
	This is the header line.
	This is the first data line.
	This is the second data line.
	This is the last line.
	$
	$ sed '/first/{ N ; s/\n/ / }' data2.txt
	This is the header line.
	This is the first data line. This is the second data line.
	This is the last line.
	$
	//
	The sed editor script searches for the line of text that contains the word “first” in it. When
	it finds the line, it uses the N command to combine the next line with that line. It then
	uses the substitution command (s) to replace the newline character with a space. The
	result is that the two lines in the text file appear as one line in the sed editor output.
	-------------------------------------------------------------------------------
	$ cat data4.txt
	On Tuesday, the Linux System
	Administrator's group meeting will be held.
	All System Administrators should attend.
	$
	$ sed 'N
	> s/System\nAdministrator/Desktop\nUser/
	> s/System Administrator/Desktop User/
	> ' data4.txt
	On Tuesday, the Linux Desktop
	User's group meeting will be held.
	All System Administrators should attend.
	$
	-------------------------------------------------------------------------------
	$ sed '
	> s/System Administrator/Desktop User/
	> N
	> s/System\nAdministrator/Desktop\nUser/
	> ' data4.txt
	On Tuesday, the Linux Desktop
	User's group meeting will be held.
	All Desktop Users should attend.
	$
	-----------------------------------------------------------------
	- Multiline delete command:
	----------------------------------------------------------------
	$ sed 'N ; /System\nAdministrator/d' data4.txt
	All System Administrators should attend.
	$
	----------------------------------------------------------------
	$ sed 'N ; /System\nAdministrator/D' data4.txt
	Administrator's group meeting will be held.
	All System Administrators should attend.
	$
	---------------------------------------------------------------
	- Holding space:
		The pattern space is an active buffer area that holds the text examined by the sed editor
		while it processes commands. However, it isn’t the only space available in the sed editor for
		storing text.
		The sed editor utilizes another buffer area called the hold space. You can use the hold
		space to temporarily hold lines of text while working on other lines in the pattern space.
	Command 	Description
	  h 		Copies pattern space to hold space
	  H 		Appends pattern space to hold space
	  g 		Copies hold space to pattern space
	  G 		Appends hold space to pattern space
	  x 		Exchanges contents of pattern and hold spaces
	-------------------------------------------------------------------
	$ cat data2.txt
	This is the header line.
	This is the first data line.
	This is the second data line.
	This is the last line.
	$
	$ sed -n '/first/ {h ; p ; n ; p ; g ; p }' data2.txt
	This is the first data line.
	This is the second data line.
	This is the first data line.
	$
	//
	1. The sed script uses a regular expression in the address to fi lter the line containing
	the word first.
	2. When the line containing the word first appears, the initial command in {}, the
	h command, places the line in the hold space.
	3. The next command, the p command, prints the contents of the pattern space,
	which is still the fi rst data line.
	4. The n command retrieves the next line in the data stream
	(This is the second data line) and places it in the pattern space.
	5. The p command prints the contents of the pattern space, which is now the second
	data line.
	6. The g command places the contents of the hold space
	(This is the first data line) back into the pattern space, replacing the
	current text.
	7. The p command prints the current contents of the pattern space, which is now back
	to the first data line.
+ Changing the flow:
	- Branching:
	---------------------------------------------------------
	$ cat data2.txt
	This is the header line.
	This is the first data line.
	This is the second data line.
	This is the last line.
	$
	$ sed '{2,3b ; s/This is/Is this/ ; s/line./test?/}' data2.txt
	Is this the header test?
	This is the first data line.
	This is the second data line.
	Is this the last test?
	$
	--------------------------------------------------------
	$ sed '{/first/b jump1 ; s/This is the/No jump on/
	> :jump1
	> s/This is the/Jump here on/}' data2.txt
	No jump on header line
	Jump here on first data line
	No jump on second data line
	No jump on last line
	$
	-------------------------------------------------------
	- Testing:
	------------------------------------------------------
	$ sed '{
	> s/first/matched/
	> t
	> s/This is the/No match on/
	> }' data2.txt
	No match on header line
	This is the matched data line
	No match on second data line
	No match on last line
	$
+ Replacing via a Pattern:
	- Using the ampersand: &
	---------------------------------------------------------
	$ echo "The cat sleeps in his hat." | sed 's/.at/"&"/g'
	The "cat" sleeps in his "hat".
	$
	// g, indicating that new text should be substituted for all occurrences of the existing text.
+ Placing sed commands in scripts:
	- Using wrappers:
	---------------------------------------------------------
	$ cat reverse.sh
	#!/bin/bash
	# Shell wrapper for sed editor script.
	#		to reverse text file lines.
	#
	sed -n '{ 1!G ; h ; $p }' $1
	#
	$
	$ ./reverse.sh data2.txt
	This is the last line.
	This is the second data line.
	This is the first data line.
	This is the header line.
	$
+ Creating sed utilities:
	- Spacing with double lines:
	---------------------------------------------------------
	$ sed '$!G' data2.txt
	This is the header line.

	This is the first data line.

	This is the second data line.

	This is the last line.
	$
	--------------------------------------------------
	- Numbering lines:
	---------------------------------------------------------
	$ sed '=' data2.txt | sed 'N; s/\n/ /'
	1 This is the header line.
	2 This is the first data line.
	3 This is the second data line.
	4 This is the last line.
	$
	---------------------------------------------------
	- Deleteing consecutive blank lines:
	---------------------------------------------------------
	$ cat data8.txt
	This is line one.


	This is line two.

	This is line three.



	This is line four.
	$
	$ sed '/./,/^$/!d' data8.txt
	This is line one.

	This is line two.

	This is line three.

	This is line four.
	$
	---------------------------------------------------
	- Deleting leading blank lines:
	---------------------------------------------------------
	$ cat data9.txt


	This is line one.

	This is line two.
	$
	$ sed '/./,$!d' data9.txt
	This is line one.

	This is line two.
	$
	--------------------------------------------------------
	- Deleting trailing blank lines:
	---------------------------------------------------------
	$ cat data10.txt
	This is the first line.
	This is the second line.



	$ sed '{
	> :start
	> /^\n*$/{$d ; N ; b start }
	> }' data10.txt
	This is the first line.
	This is the second line.
	$
	---------------------------------------------------------
	- Removing HTML tags:
	---------------------------------------------------------
	$ cat data11.txt
	<html>
	<head>
	<title>This is the page title</title>
	</head>
	<body>
	<p>
	This is the <b>first</b> line in the Web page.
	This should provide some <i>useful</i>
	information to use in our sed script.
	</body>
	</html>
	$
	$ sed 's/<[^>]*>//g ; /^$/d' data11.txt
	This is the page title
	This is the first line in the Web page.
	This should provide some useful
	information to use in our sed script.
	$
---------------------------------------------------------------------
* Advanced gawk
---------------------------------------------------------------------
+ Using variables:
	- Built-in variables:
	Variable 	Description
	FIELDWIDTHS 	A space-separated list of numbers defining the exact width (in spaces) of each data field
	FS 		Input field separator character
	RS 		Input record separator character
	OFS 		Output field separator character
	ORS 		Output record separator character
	-------------------------------------------------------------------------
	$ cat data1
	data11,data12,data13,data14,data15
	data21,data22,data23,data24,data25
	data31,data32,data33,data34,data35
	$ gawk 'BEGIN{FS=","} {print $1,$2,$3}' data1
	data11 data12 data13
	data21 data22 data23
	data31 data32 data33
	$
	---------------------------------------------------------------------
	$ gawk 'BEGIN{FS=","; OFS="-"} {print $1,$2,$3}' data1
	data11-data12-data13
	data21-data22-data23
	data31-data32-data33
	$ gawk 'BEGIN{FS=","; OFS="--"} {print $1,$2,$3}' data1
	data11--data12--data13
	data21--data22--data23
	data31--data32--data33
	$ gawk 'BEGIN{FS=","; OFS="<-->"} {print $1,$2,$3}' data1
	data11<-->data12<-->data13
	data21<-->data22<-->data23
	data31<-->data32<-->data33
	$
	--------------------------------------------------------------------
	$ cat data1b
	1005.3247596.37
	115-2.349194.00
	05810.1298100.1
	$ gawk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' data1b
	100 5.324 75 96.37
	115 -2.34 91 94.00
	058 10.12 98 100.1
	$
	-------------------------------------------------------------------
	$ cat data2
	Riley Mullen
	123 Main Street
	Chicago, IL 60601
	(312)555-1234

	Frank Williams
	456 Oak Street
	Indianapolis, IN  46201
	(317)555-9876

	Haley Snell
	4231 Elm Street
	Detroit, MI 48201
	(313)555-4938
	$ gawk 'BEGIN{FS="\n"; RS=""} {print $1,$4}' data2
	Riley Mullen (312)555-1234
	Frank Williams (317)555-9876
	Haley Snell (313)555-4938
	$
	----------------------------------------------------------------
	- Data variables:
	Variable 	Description
	ARGC 		The number of command line parameters present
	ARGIND 		The index in ARGV of the current file being processed
	ARGV 		An array of command line parameters
	CONVFMT 	The conversion format for numbers (see the printf statement), with a default value of %.6 g
	ENVIRON 	An associative array of the current shell environment variables and their values
	ERRNO 		The system error if an error occurs when reading or closing input files
	FILENAME 	The filename of the data fi le used for input to the gawk program
	FNR 		The current record number in the data file
	IGNORECASE 	If set to a non-zero value, ignores the case of characters in strings used in the gawk command
	NF 		The total number of data fields in the data file
	NR 		The number of input records processed
	OFMT 		The output format for displaying numbers, with a default of %.6 g
	RLENGTH 	The length of the substring matched in the match function
	RSTART 		The start index of the substring matched in the match function	
	-------------------------------------------------------------------
	$ gawk '
	> BEGIN{
	> print ENVIRON["HOME"]
	> print ENVIRON["PATH"]
	> }'
	/home/rich
	/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin
	$
	-------------------------------------------------------------------
	$ gawk 'BEGIN{FS=","}{print $1,"FNR="FNR}' data1 data1
	data11 FNR=1	
	data21 FNR=2	
	data31 FNR=3	
	data11 FNR=1	
	data21 FNR=2	
	data31 FNR=3
	$
	------------------------------------------------------------------
	$ gawk '
	> BEGIN {FS=","}
	> {print $1,"FNR="FNR,"NR="NR}
	> END{print "There were",NR,"records processed"}' data1 data1
	data11 FNR=1 NR=1
	data21 FNR=2 NR=2
	data31 FNR=3 NR=3
	data11 FNR=1 NR=4
	data21 FNR=2 NR=5
	data31 FNR=3 NR=6
	There were 6 records processed
	$
	------------------------------------------------------------------
	- User-defined variables:
	-----------------------------------------------------------------
	$ gawk '
	> BEGIN{
	> testing="This is a test"
	> print testing
	> testing=45
	> print testing
	> }'
	This is a test
	45
	$
	-------------------------------------------------------------------
	$ gawk 'BEGIN{x=4; x= x * 2 + 3; print x}'
	11
	$
	-------------------------------------------------------------------
	$ cat script1
	BEGIN{FS=","}
	{print $n}
	$ gawk -f script1 n=2 data1
	data12
	data22
	data32
	$ gawk -f script1 n=3 data1
	data13
	data23
	data33
	$
	-------------------------------------------------------------------
	$ cat script2
	BEGIN{print "The starting value is",n; FS=","}
	{print $n}
	$ gawk -v n=3 -f script2 data1
	The starting value is 3
	data13
	data23
	data33
	$
+ Working with arrays:
	- Defining array varibles:
	-----------------------------------------------------------------
	$ gawk 'BEGIN{
	> capital["Illinois"] = "Springfield"
	> print capital["Illinois"]
	> }'
	Springfield
	$
	----------------------------------------------------------------
	$ gawk 'BEGIN{
	> var[1] = 34
	> var[2] = 3
	> total = var[1] + var[2]
	> print total
	> }'
	37
	$
	---------------------------------------------------------------
	- Iterating through array variables:
	--------------------------------------------------------------
	$ gawk 'BEGIN{
	> var["a"] = 1	
	> var["g"] = 2	
	> var["m"] = 3	
	> var["u"] = 4	
	> for (test in var)
	> {
	>    print "Index:",test," - Value:",var[test]
	> }
	> }'
	Index: u   - Value: 4
	Index: m   - Value: 3
	Index: a   - Value: 1
	Index: g   - Value: 2
	$
	--------------------------------------------------------------
	- Deleting array:
	--------------------------------------------------------------
	$ gawk 'BEGIN{
	> var["a"] = 1
	> var["g"] = 2
	> for (test in var)
	> {
	>
	print "Index:",test," - Value:",var[test]
	> }
	> delete var["g"]
	> print "---"
	> for (test in var)
	>
	print "Index:",test," - Value:",var[test]
	> }'
	Index: a - Value: 1
	Index: g - Value: 2
	---
	Index: a - Value: 1
	$
+ Using pattern:
	- Regular expressions:
	--------------------------------------------------------------
	$ gawk 'BEGIN{FS=","} /11/{print $1}' data1
	data11
	$
	---------------------------------------------------------------
	- The matching operator
	---------------------------------------------------------------
	$ gawk -F: '$1 ~ /rich/{print $1,$NF}' /etc/passwd
	rich /bin/bash
	$
	------------------------------------------------------------
	- Mathematical expressions:
	------------------------------------------------------------
	$ gawk -F, '$1 == "data"{print $1}' data1
	$
	$ gawk -F, '$1 == "data11"{print $1}' data1
	data11
	$
+ Structured commands:
	- The if statement:
	-------------------------------------------------------------
	$ cat data4
	10
	5
	13
	50
	34
	$ gawk '{if ($1 > 20) print $1}' data4
	50
	34
	$
	---------------------------------------------------------------
	$ gawk '{
	> if ($1 > 20)
	> {
	>   x = $1 * 2
	>   print x
	> }
	> }' data4
	100
	68
	$
	--------------------------------------------------------------
	$ gawk '{
	> if ($1 > 20)
	> {
	>    x = $1 * 2
	>    print x
	> } else
	> {
	>    x = $1 / 2
	>    print x
	> }}' data4
	5
	2.5
	6.5
	100
	68
	$
	------------------------------------------------------------
	- The while statement:
	-----------------------------------------------------------
	$ cat data5
	130 120 135
	160 113 140
	145 170 215
	$ gawk '{
	> total = 0
	> i = 1
	> while (i < 4)
	> {
	>    total += $i
	>    i++
	> }
	> avg = total / 3
	> print "Average:",avg
	> }' data5
	Average: 128.333
	Average: 137.667
	Average: 176.667
	$
	-------------------------------------------------------------
	- The do-while statement:
	-------------------------------------------------------------
	$ gawk '{
	> total = 0
	> i = 1
	> do
	> {
	>    total += $i
	>    i++
	> } while (total < 150)
	> print total }' data5
	250
	160
	315
	$
	-----------------------------------------------------------
	- The for statement:
	-----------------------------------------------------------
	$ gawk '{
	> total = 0
	> for (i = 1; i < 4; i++)
	> {
	>    total += $i
	> }
	> avg = total / 3
	> print "Average:",avg
	> }' data5
	Average: 128.333
	Average: 137.667
	Average: 176.667
	$
+ Formatted printing:
	Control 	Letter Description
	c 		Displays a number as an ASCII character
	d 		Displays an integer value
	i 		Displays an integer value (same as d)
	e 		Displays a number in scientific notation
	f 		Displays a floating-point value
	g 		Displays either scientific notation or floating point, whichever is shorter
	o 		Displays an octal value
	s 		Displays a text string
	x 		Displays a hexadecimal value
	X 		Displays a hexadecimal value, but using capital letters for A through F
	-----------------------------------------------------------------------
	$ gawk 'BEGIN{
	> x = 10 * 100
	> printf "The answer is: %e\n", x
	> }'
	The answer is: 1.000000e+03
	$
	----------------------------------------------------------------------
	$ gawk 'BEGIN{FS="\n"; RS=""} {print $1,$4}' data2
	Riley Mullen (312)555-1234
	Frank Williams (317)555-9876
	Haley Snell (313)555-4938
	$
	----------------------------------------------------------------------
	$ gawk 'BEGIN{FS="\n"; RS=""} {printf "%s %s\n", $1, $4}' data2
	Riley Mullen (312)555-1234
	Frank Williams (317)555-9876
	Haley Snell (313)555-4938
	$
	----------------------------------------------------------------------
	$ gawk 'BEGIN{FS="\n"; RS=""} {printf "%16s  %s\n", $1, $4}' data2
	    Riley Mullen   (312)555-1234
	Frank Williams     (317)555-9876
	   Haley Snell     (313)555-4938
	$
	--------------------------------------------------------------------
	gawk '{
	$ total = 0
	> for (i = 1; i < 4; i++)
	> {
	>    total += $i
	> }
	> avg = total / 3
	> printf "Average: %5.1f\n",avg
	> }' data5
	Average: 128.3
	Average: 137.7
	Average: 176.7
	$
+ Built-in functions:
	- Mathematical functions:
	Function 	Description
	atan2(x, y) 	The arctangent of x / y, with x and y specified in radians
	cos(x) 		The cosine of x, with x specified in radians
	exp(x) 		The exponential of x
	int(x) 		The integer part of x, truncated toward 0
	log(x) 		The natural logarithm of x
	rand() 		A random floating point value larger than 0 and less than 1
	sin(x) 		The sine of x, with x specified in radians
	sqrt(x) 	The square root of x
	srand(x) 	Specifies a seed value for calculating random numbers
	-------------------------------------------------------------------
	- String functions:
	Function 		Description
	asort(s [,d]) 		This function sorts an array s based on the data element values.
				The index values are replaced with sequential numbers indicating 
				the new sort order. Alternatively, the new sorted array is
				stored in array d if specifi ed.
	asorti(s [,d]) 		This function sorts an array s based on the index values. The
				resulting array contains the index values as the data element values, 
				with sequential number indexes indicating the sort order.
				Alternatively, the new sorted array is stored in array d if specifi ed.
	gensub(r, s, h [, t]) 	This function searches either the variable $0, or the target string
				t if supplied, for matches of the regular expression r. If h is a
				string beginning with either g or G, it replaces the matching text
				with s. If h is a number, it represents which occurrence of r to
				replace.
	gsub(r, s [,t]) 	This function searches either the variable $0, or the target string
				t if supplied, for matches of the regular expression r. If found, it
				substitutes the string s globally.
	index(s, t) 		This function returns the index of the string t in string s, or 0 if
				not found.
	length([s]) 		This function returns the length of string s, or if not specifi ed, the
				length of $0.
	match(s, r [,a]) 	This function returns the index of the string s where the regular
				expression r occurs. If array a is specifi ed, it contains the portion
				of s that matches the regular expression.
	split(s, a [,r]) 	This function splits s into array a using either the FS character, or
				the regular expression r if supplied. It returns the number of
				fi elds.
	sprintf(format,
	variables) 		This function returns a string similar to the output of printf
				using the format and variables supplied.
	sub(r, s [,t]) 		This function searches either the variable $0, or the target string
				t, for matches of the regular expression r. If found, it substitutes
				the string s for the fi rst occurrence.
	substr(s, i [,n]) 	This function returns the nth character substring of s, starting at
				index i. If n is not supplied, the rest of s is used.
	tolower(s) 		This function converts all characters in s to lowercase.
	toupper(s) 		This function converts all characters in s to uppercase.
	---------------------------------------------------------------------------
	$ gawk 'BEGIN{x = "testing"; print toupper(x); print length(x) }'
	TESTING
	7
	$
+ User-defined functions:
	- Defining a function:
	function name([variables])
	{
	   statements
	}
	------------------------------------------------------------------------
	function myrand(limit)
	{
	   return int(limit * rand())
	}
	----------------------------------------------------------------------
	- Using your functions:
	---------------------------------------------------------------------
	$ gawk '
	> function myprint()
	> {
	>     printf "%-16s - %s\n", $1, $4
	> }
	> BEGIN{FS="\n"; RS=""}
	> {
	>     myprint()
	> }' data2
	Riley Mullen     - (312)555-1234
	Frank Williams   - (317)555-9876
	Haley Snell      - (313)555-4938
	$
	----------------------------------------------------------------------
	- Creating a function library:
	----------------------------------------------------------------------
	$ cat funclib
	function myprint()
	{
	   printf "%-16s - %s\n", $1, $4
	}
	function myrand(limit)
	{
	   return int(limit * rand())
	}
	function printthird()
	{
	   print $3
	}
	$
	$ cat script4
	BEGIN{ FS="\n"; RS=""}
	{
	    myprint()
	}
	$ gawk -f funclib -f script4 data2
	Riley Mullen     - (312)555-1234
	Frank Williams   - (317)555-9876
	Haley Snell      - (313)555-4938
	$	
